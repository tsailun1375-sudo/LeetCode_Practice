# 204. Count Primes (計算質數)

### 題目資訊
/*
 * 題目：204. Count Primes
 * 連結：https://leetcode.com/problems/count-primes/
 * 難度：Medium
 * 描述：計算嚴格小於非負整數 n 的質數數量。
 */

### 解題思路
本題最初採用 **暴力搜尋法 (Brute Force)**，遍歷 $2$ 到 $n-1$ 的每個數字並逐一判斷是否為質數。然而，判斷單一數字是否為質數的時間複雜度為 $O(\sqrt{n})$，導致總複雜度達到 $O(n\sqrt{n})$，在 $n$ 較大時會發生 **TLE (Time Limit Exceeded)**。

為了優化效能，改採用 **埃拉托斯特尼篩法 (Sieve of Eratosthenes)**：
1. 建立一個長度為 $n$ 的布林陣列 `is_prime` 並初始化為 `True`。
2. 從 $2$ 開始遍歷，若當前數字 $i$ 為質數，則將其所有倍數（從 $i \times i$ 開始）標記為 `False`。
3. 遍歷上限僅需至 $\sqrt{n}$，最終統計陣列中為 `True` 的個數即可。



### 複雜度分析
- **時間複雜度**: $O(n \log \log n)$  
  相較於暴力法，篩法極大程度地減少了重複檢查的次數，是處理大規模範圍質數問題的最佳解法。
- **空間複雜度**: $O(n)$  
  需要額外使用一個長度為 $n$ 的陣列來存儲每個數字的標記狀態。

### 學習筆記
這題是我在處理大規模數據優化上的重要練習，主要心得如下：
1. **理解 TLE 的限制**：當 $n$ 高達 $5 \times 10^6$ 時，直覺的暴力解法已不再適用。這讓我學會在撰寫程式前先估算時間複雜度與測資規模。
2. **思維轉換**：從「主動判斷每個數是否為質數」轉變為「被動排除掉所有合數」，這種排除法的邏輯是大幅提升效能的核心。
3. **數學優化技巧**：學會了為什麼篩選範圍只需到 $\sqrt{n}$ 以及為什麼倍數標記可以從 $i^2$ 開始，這些細節能進一步減少無謂的運算。
4. **效能意識**：這題讓我深刻體會到，選擇正確的演算法比寫出簡潔的程式碼更重要，尤其是在面對有嚴格執行時間限制的題目時。
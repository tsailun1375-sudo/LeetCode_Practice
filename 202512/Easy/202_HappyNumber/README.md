# LeetCode 202. Happy Number - 思維演進筆記

## 📌 題目核心
判斷一個數字經過「位數平方和」轉換後，最終會收斂至 1（快樂數），還是會陷入無限循環（非快樂數）。

---

## 💡 解法演進：從迷惘到優化

### 第一階段：毫無頭緒 (Initial Struggle)
最初看到題目時，最大的困擾在於**「判斷終止條件」**。
* **我的疑問**：如果不變成 1，數字會一直變大到無窮大嗎？還是會停在某個地方？
* **困境**：不知道何時該放棄搜索並判定它為「非快樂數」，導致程式碼邏輯難以下筆。

### 第二階段：紀錄法 (Set/Record Approach) - 初覺可行
接著我想到，如果數字不會變成 1，它在有限的範圍內一定會**「重複出現」**。
* **構思**：建立一個記事本（如 `std::set`），把所有出現過的轉換結果通通記下來。
* **邏輯**：每次算出新數字，就去查表，如果數字已經出現過，就代表進入了「死循環」。
* **瓶頸**：雖然能解題，但隨著數字變多，**空間複雜度會達到 $O(n)$**。對於記憶體受限的環境或超大數據，這不是最優雅的解法。

### 第三階段：快慢指標法 (Floyd's Cycle-Finding) - 最終突破
為了追求效能極限，我研究出了不需要額外空間的檢測方式。將數字轉換過程想像成一條「路徑」，死循環就像是「環狀賽道」。

1. **核心原理**：**「龜兔賽跑」**。快指標（兔）每次跑兩步，慢指標（龜）每次跑一步。
2. **判斷邏輯**：
   - 如果是快樂數，快指標會先抵達 1。
   - 如果不是快樂數，快指標最終會在循環中從後面「套圈」追上慢指標（`fast == slow`）。
3. **優點**：完全不需要額外儲存空間。

---

## 📈 複雜度分析與轉變

| 指標 | 紀錄法 (HashSet) | 快慢指標 (Floyd's Algorithm) |
| :--- | :--- | :--- |
| **時間複雜度** | $O(\log n)$ | $O(\log n)$ |
| **空間複雜度** | **$O(n)$** | **$O(1)$** |
| **效能分析** | 需隨數字增長消耗記憶體 | **極優**，僅使用常數個變數 |
| **邏輯核心** | 依賴外部記憶進行比對 | 依賴速度差偵測結構特性 |

---

## 🌟 學習總結
這題對我的啟發是：**當空間成本過高時，利用「速度差」來偵測結構特性是非常強大的技巧。** 這種不開闢額外空間就能偵測死循環的思維，讓我在處理類似的鏈結串列或數學邏輯題時，擁有了從 $O(n)$ 優化到 $O(1)$ 的能力。